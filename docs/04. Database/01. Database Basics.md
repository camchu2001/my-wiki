> A **database** is an organized collection of structured information or data, typically stored and accessed electronically. Databases are managed by **Database Management Systems (DBMS)**, a software that provides an interface for users and applications to create, retrieve, update, and delete data efficiently and securely.

## I. Database Management System (DBMS)
A **Database Management System** (DBMS) is specialized software that facilitates creating, maintaining, and using electronic databases. It   
- makes it easy to manage large amounts of information
- handles security 
- does backups
- import/export data
- concurrency
- interacts with other software applications

The database management system is not the actual database, it is the software application that is creating, maintaining, updating, and deleting information from the actual database. 
### Types of Databases
#### 1. Relational Databases (SQL)
Organize data into more or more tables. 
- Each table has columns and rows. 
- A **unique** key identifies each row, e.g., `id`, `username`.

Popular **Relational Database Management Systems (RDBMS)** are ***PostgreSQL, MySQL, MariaDB, Oracle, etc.*** 

Relational database management systems use **Structured Query Language (SQL)**. 
- A standardized language for managing and manipulating relational databases. 
- It performs **C.R.U.D. operations** and **administrative tasks** (user management, security, backup, etc). 
- It’s used to define tables and structures. 
- SQL code used on one RDBMS is not always portable to another without modification. 

![](https://i.imgur.com/D2Dw6ou.png)
#### 2. Non-Relational (no SQL / not just SQL)
Non-relational databases (NoSQL databases) organize data using flexible schemas that differ from the traditional table-based structure of relational databases. 
- Key-value stores
- Documents (JSON, XML, etc.)
- Graphs
- Flexible Tables

Popular **Non-Relational Database Management Systems (NRDBMS)** are **MongoDB, dynamoDB, firebase,** etc. 

- Any non-relational database falls under this category, so there’s no set language standard. 
- Most NRDBMS will implement their language for performing C.R.U.D and administrative operations on the database. 
#### 3. Database Queries
Queries are requests made to the database management system for specific information. 
As the database’s structure becomes more and more complex, it becomes more difficult to get the specific pieces of information we want. 
→ We can write a complex database query, instructing the DBMS to grab specific information from the database.
## II. Database Tables
![](https://i.imgur.com/eY0TI1I.png)

A column would define a single attribute, a row is an individual entry in the student table. 
### 1. Primary Key
When creating a table in the database, we want to create a **primary key attribute** (`student_id`). A **primary key** is a column or set of columns that uniquely identifies each row in a table, ensuring data integrity and providing a means for establishing relationships between tables.

In database design, the terms **surrogate key** and **natural key** also refer to types of primary keys.
- A **surrogate key** is an artificial key that is not derived from the application data. It is typically a sequential number (like an auto-incremented integer). It has **no** **meaning** or intrinsic value **outside the database** context. → simple, stable, and guarantees uniqueness.
- A **natural key** is a key that is derived **from the actual data**. It often comes from the business logic, like a Social Security Number (SSN), email address, or a combination of fields → can sometimes be problematic if the business logic/data changes.
### 2. Foreign Key
A **foreign key** is a column or set of columns in one table that refers to the primary key in another table, establishing a link between the two tables.

<u>**Example 1**</u>: 

| ![](https://i.imgur.com/wAmG5FV.png) | ![300](https://i.imgur.com/6IiuJCc.png) |
| ------------------------------------ | --------------------------------------- |
|                                      |                                         |

A company can have different branches, and we can store information about an employee’s branch using a foreign key. 
- Within the `employees` table, we have a foreign key `branch_id`. `branch_id` is the primary key of the `branches` table. 
- Now, we will know which branch an employee belongs to without storing branch information on the `employees` table. 

A table can **have more than one foreign key** on it. 

<u>**Example 2:** </u>
Here, the `employees` table has two foreign keys: 
- `branch_id`, which points to the `branches` table 
- `super_id`, which defines the supervisor of a particular employee and points back to the `employees` table (the same table)
→ using the `super_id`, we can define the relationship between employees 
![](https://i.imgur.com/B7qKuoU.png)
### 3. Composite Key
A **composite key**, also known as a compound key, is a primary key that consists of two or more columns in a table. These columns, when combined, uniquely identify each record in the table. No single column of a composite key is capable of uniquely identifying the records on its own.

<u>**Example**</u>: 
- `flight_number`: is not unique on its own because the same flight number is used for recurring flights (e.g., daily flights).
- `departure_date`: is not unique on its own because multiple flights depart on the same day.
- `seat_number`: is not unique on its own because the same seat number exists on different flights.
→ When combined, these three columns create a unique identifier for each booking. 

```
+----------------+----------------+-------------+------------------+
| flight_number* | departure_date*| seat_number*| passenger_name   |
+----------------+----------------+-------------+------------------+
| FL123          | 2024-07-15     | 12A         | John Doe         |
| FL123          | 2024-07-15     | 12B         | Jane Smith       |
| FL456          | 2024-07-16     | 1C          | Alice Johnson    |
+----------------+----------------+-------------+------------------+
```
### 4. Joiner Table
A **joiner table** is a table in a relational database used to connect two or more tables, typically to resolve **many-to-many** relationships. Its primary key is usually a **composite key** composed of foreign keys referencing the primary keys of the tables it's connecting.

<u>**Example**</u>: 
We have the `employees` and `clients` tables. To express the many-to-many relationship where an employee can work with multiple clients and a client can be served by multiple employees, we create a joiner table called `works_with`.

| ![](https://i.imgur.com/mztkrVp.png) | ![](https://i.imgur.com/O8a9ss7.png) |
| ------------------------------------ | ------------------------------------ |
|                                      |                                      |
```

+--------+-----------+-------------+
| emp_id | client_id | total_sales |
+--------+-----------+-------------+
| 107    | 400       | 55,000      |
| 101    | 400       | 267,000     |
| 101    | 404       | 22,500      |
+--------+-----------+-------------+
```

The joiner table `works_with` has a composite primary key consisting of `emp_id` and `client_id`. This combination uniquely identifies each employee-client relationship.
    - `emp_id` is a foreign key referencing the `employees` table.
    - `client_id` is likely a foreign key referencing the `clients` table.
## III. Relational Database Design
> **Resources**
> - [Database Design](https://youtu.be/ztHopE5Wnpc?si=KeEEXdZda1TIWcMD&t=2837)

**Database design** is the process of **organizing** and **structuring** data in a <u>**logical**</u> manner to efficiently store, manage, and retrieve information in a database system. It involves defining the database structure, relationships between data elements, and constraints to ensure data integrity and consistency.

Database design is important for several reasons:
1. **Efficiency**: A well-designed database optimizes data storage and retrieval, improving system performance.
2. **Data integrity**: Proper design helps maintain accurate and consistent data across the database.
3. **Scalability**: Good design allows the database to grow and adapt to changing requirements over time.
4. **Reduced redundancy**: It minimizes data duplication, saving storage space and reducing inconsistencies.
5. **Improved data security**: Proper design facilitates the implementation of access controls and security measures.
### 1. Schema Design
A database **schema** is a <u>***formal description***</u> of the structure, organization, and relationships of data within a database. It serves as a ***blueprint*** for how data is stored and accessed. The schema defines:
1. Tables and their attributes (columns)
2. Relationships between tables
3. Constraints and rules for data integrity
4. Data types for each attribute
5. Indexes and other performance optimization structures

There are **three levels** to schema design. These three levels form a progression from abstract to concrete, with each level adding more detail and specificity.
#### 1. Conceptual
- This is the highest level of abstraction.
- It provides a big-picture view of what the database will contain.
- It focuses on identifying main entities, their attributes, and relationships.
- Usually represented using an Entity-Relationship Diagram (ERD).
- Does not include technical details.
#### 2. Logical
- This is a more detailed representation of the database structure.
- It translates the conceptual model into a specific data model (e.g., relational, object-oriented).
- Defines tables, columns, relationships, and constraints.
- Still independent of any specific database management system (DBMS).
#### 3. Physical
- This is the lowest level, describing how data is actually stored.
- It includes specific details for implementation in a particular DBMS.
- Defines storage structures, file organizations, indexes, access methods, and security measures.
- Optimized for performance on the chosen DBMS platform.
### 2. Data Integrity
