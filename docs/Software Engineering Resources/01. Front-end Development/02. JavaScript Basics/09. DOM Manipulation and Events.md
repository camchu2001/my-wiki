> **Resource**
> - [View/Changing DOM - Chrome Dev Tool](https://developer.chrome.com/docs/devtools/dom)

The DOM (or Document Object Model) is a **tree-like representation** of the contents of a webpage. It **represents the structure of the HTML document** as a **tree structure**, with each element, attribute, and text node represented as a **node** in the tree.
```
div#container -- parent
├── div.display -- children
└── div.controls -- children
```
## 1. DOM Methods
When your HTML code is parsed by a web browser, it is ***converted*** to the DOM. The DOM tree nodes are **JavaScript objects** that have many **properties and methods** attached to them. 
JavaScript provides a set of **built-in methods and properties** for <u>**manipulating the DOM**</u>. These properties and methods are the **primary tools** used to manipulate our webpage.

> Manipulating with the DOM is essentially interacting with the in-memory representation of the document that the browser creates based on the original HTML code. This in-memory representation is what's rendered and displayed in the browser window.
→ The changes made to the DOM **do not directly affect the original HTML file** on disk.
### 1. Query Selectors
- **`element.querySelector(selector)`** - returns a reference to the first match of _selector_.
- **`element.querySelectorAll(selectors)`** - returns a “**NodeList**” containing references to all the matches of the _selectors_.
	- When using `querySelectorAll`, the return value is **not** an array. It looks like an array, and it somewhat acts like an array, but it’s really a “NodeList”.
> `querySelector()` and `querySelectorAll()` on any element within the document, not just `document` itself.
```html
<!-- the HTML file -->
<div id="container"> 
  <p class="example">Paragraph 1</p> 
  <p class="example">Paragraph 2</p> 
  <p class="another">Paragraph 3</p> 
</div>
```

```js
// index.js
// document represents the entire HTML document
const container = document.querySelector('#container'); 

// querySelector() called on the container element
// and the querySelectorAll() is called on the entire html document
const firstExampleParagraph = container.querySelector('.example');
const allParagraphs = document.querySelectorAll('p');
```
### 2. Create Elements
**`document.createElement(tagName, [options])`**:  creates a **new element** of tag type tagName. 
* `[options]` in this case means you can add some optional parameters to the function.
The `createElement()` method is a method of the `document` object, not of individual elements, e.g. `container`. It's used to create new elements **within the document, not within specific elements.**
```html
<!-- the HTML file -->
<div id="container"> 
  <p class="example">Paragraph 1</p> 
  <p class="example">Paragraph 2</p> 
  <p class="another">Paragraph 3</p> 
</div>
```

```javascript
// index.js
const div = document.createElement("div");
```

This function does **NOT** put your new element into the DOM - it creates it in memory. This is so that you can **manipulate the element** (by adding styles, classes, ids, text, etc.) before placing it on the page.

You can **place the element into the DOM** with one of the *append elements methods* shown below.  
### 3. Append & Remove Elements
#### 1. Append Elements
```html
<!-- the HTML file -->
<div id="container"> 
  <p class="example">Paragraph 1</p> 
  <p class="example">Paragraph 2</p> 
  <p class="another">Paragraph 3</p> 
</div>
```
- **`parentNode.appendChild(childNode)`** - appends _childNode_ as the last child of _parentNode_.
```js
// index.js

// create div element - like shown in createElement()
// childNode
const div = document.createElement("div");

// parentNode
const container = document.querySelector('#container'); 

// Appends the newly created <div> element as the last child of the container element
container.appendChild(div); 
```
- **`parentNode.insertBefore(newNode, referenceNode)`** - inserts _newNode_ into _parentNode_ before _referenceNode_.
```js
// parentNode - like shown ealier
const container = document.querySelector('#container'); 

// newNode
const paragraph = document.createElement("p"); 

// referenceNode - first example paragraph in container element
const referenceNode = container.querySelector('.example');

// insert paragraph into container before the first example paragraph
container.insertBefore(paragraph, referenceNode)
```
#### 2. Remove Elements
- **`parentNode.removeChild(child)`** - removes _child_ from _parentNode_ on the DOM and returns a reference to _child_.
```js
// container is the parentNode
// paragraph is the childNode

// removes the paragraph element from the container
container.removeChild(paragraph); 
```
### 4. Altering Elements
When you have a **reference to an element**, you can use that reference to **alter the element’s own properties**, like: 
* adding inline style information
* adding/removing/altering attributes
* changing classes
* etc. 
#### 1. Adding Inline Style
```javascript
// creates a new <div> referenced in the variable 'div'
const div = document.createElement("div");
```

```javascript
// adds the indicated style rule to the element in the div variable
div.style.color = "blue";

// adds several style rules
div.style.cssText = "color: blue; background: white;";

// adds several style rules
div.setAttribute("style", "color: blue; background: white;");
```
* When accessing a **kebab-case CSS property** like `background-color` with JS, you will need to either use **camelCase with dot notation or bracket notation**.
```javascript
// dot notation with kebab case: doesn't work as it attempts to subtract color from div.style.background
// equivalent to: div.style.background - color
div.style.background-color;

// dot notation with camelCase: works, accesses the div's background-color style
div.style.backgroundColor;

// bracket notation with kebab-case: also works
div.style["background-color"];

// bracket notation with camelCase: also works
div.style["backgroundColor"];
```
#### 2. Editing Attributes
> **Resource**
> - [HTML Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)

```javascript
// if id exists, update it to 'theDiv', else create an id with value "theDiv"
div.setAttribute("id", "theDiv");

// returns value of specified attribute, in this case "theDiv"
div.getAttribute("id");

// removes specified attribute
div.removeAttribute("id");
```
#### 3. Working with Classes
```javascript
// adds class "new" to your new div
div.classList.add("new");

// removes "new" class from div
div.classList.remove("new");

// if div doesn't have class "active" then add it, or if it does, then remove it
div.classList.toggle("active");
```
→ It is often **standard (and cleaner)** to define CSS classes containing the desired styles rather than adding and removing inline CSS.
#### 4. Adding Text Content
```javascript
// creates a text node containing "Hello World!" and inserts it in div
div.textContent = "Hello World!";
```
#### 5. Adding HTML Content
```javascript
// renders the HTML inside div
div.innerHTML = "<span>Hello World!</span>";
```
> `textContent` is **preferred** over `innerHTML` for adding text, as innerHTML should be used sparingly to **avoid potential security risks.**
### 5. Accessing Element’s Value
It’s just like accessing a value of an object. 
```html
<body>
<div>
	<label for="item">Enter a new item:</label>
	<input type="text" name="item" id="item">
	<button>Add item</button>
</body>
```

```js
const input = document.querySelector("input");
let inputValue = input.value;
```
### 6. `focus()` method
**`HTMLElement.focus()`** sets focus on the specified element, this element becomes the active element in the document, ready to **receive keyboard and similar events**.

In this example, `focus()` ensures that **the cursor automatically jumps back to the input field**, making it convenient to continue entering data without needing to manually click or navigate to the next input field. 
```js
input.focus()
```
## 2. Events
> **Resource**
> [JavaScript Event Reference](https://www.w3schools.com/jsref/dom_obj_event.asp)
> [JavaScript Events](https://www.javascripttutorial.net/javascript-dom/javascript-events/)

**Events** are **actions that occur on your webpage**, such as *mouse-clicks or key-presses*. Using JavaScript, we can make our webpage listen to and **react to these events**.
There are **three primary ways** to go about this:
- Specify function attributes **directly on your HTML elements**.
- Set properties in the form of **`on<eventType>`**, such as `onclick` or `onmousedown`, on the DOM nodes in your JavaScript.
- Attach **event listeners to the DOM nodes** in your JavaScript. →  preferred method. 
### 1. Inline Event Listener
In this example: 
* `onclick` is a **HTML attribute**, an **event listener** that directly **specifies a string containing the JavaScript code** to be executed when the button is clicked. This code is typically a function call, but it can be any valid JavaScript expression. 
* `alert('Hello World')` is the JavaScript code that defines the action to be taken when the button is clicked. 
```html
<!-- the HTML file -->
<button onclick="alert('Hello World')">Click Me</button>
```
→ This solution isn’t ideal because we’re cluttering our HTML elements with JavaScript. 
Also, we can **only set one `onClick` property per DOM element**, so we’re unable to run multiple separate functions in response to a click event using this method. 
### 2. Set `on<eventType>` on DOM Nodes
In this example: 
* `onclick` is a **property in JavaScript** similar but is **not exactly the same** as the `onclick` attribute in HTML. 
* It allows you to **assign a function as a event handler to the click event**. When the element is clicked, the function assigned to the `onclick` property is executed.
```html
<!-- the HTML file -->
<button id="btn">Click Me</button>
```

```js
// index.js
const button = document.querySelector("#btn"); 
button.onclick = () => alert("Hello World"); 
```
→ Moving the JS out of the HTML and into a JS file is better, but there’s still problem of a DOM element can only have one `onclick` property.
### 3. Attach Event Listeners to DOM Nodes
`addEventListener` is a **JavaScript method** used to attach event listeners to DOM elements. It usually takes in **two parameters**: 
- `eventType`: The event type (e.g., "click", "mouseover", "keydown")
- `eventHandler`: The function to be executed when the event occurs
```html
<!-- the HTML file -->
<button id="btn">Click Me Too</button>
```

```js
// index.js
const button = document.querySelector("#btn"); 

// First event listener 
button.addEventListener("click", () => { 
  alert("Hello World"); 
}); 

// Second event listener 
button.addEventListener("click", () => {
  console.log("Button clicked!"); 
});
```
→ This way **allows multiple event listeners if needed**, it’s more flexible and powerful, though it’s more complex to set up. 

> **Some useful events include:**
> - click
> - dblclick
> - keydown
> - keyup
### 4. Using 3 Methods with Named Functions
All 3 methods shown above can be **used with named functions**. Using named functions can **clean up the code** considerably.

<u>**1. Method 1:** </u>
```html
<!-- the HTML file -->
<!-- METHOD 1 -->
<button onclick="alertFunction()">CLICK ME!</button>
```

```javascript
// the JavaScript file
// METHOD 1
function alertFunction() {
  alert("YAY! YOU DID IT!");
}
```

<u>**2. Method 2 and 3:**</u>
```html
<!-- the HTML file -->
<!-- METHODS 2 & 3 -->
<button id="btn">CLICK ME!</button>
```

```javascript
// the JavaScript file
// METHODS 2 & 3
function alertFunction() {
  alert("YAY! YOU DID IT!");
}
const btn = document.querySelector("#btn");

// METHOD 2
// assigns the function itself to the event handler
btn.onclick = alertFunction;

// METHOD 3
btn.addEventListener("click", alertFunction);
```
### 5. Attaching Listeners to Group of Nodes
To add a listener to each of them, we need to i**terate through the whole list**, like so:
```html
<div id="container">
  <button id="1">Click Me</button>
  <button id="2">Click Me</button>
  <button id="3">Click Me</button>
</div>
```

```javascript
// buttons is a node list. It looks and acts much like an array.
const buttons = document.querySelectorAll("button");

// we use the .forEach method to iterate through each button
buttons.forEach((button) => {
  // and for each one we add a 'click' listener
  button.addEventListener("click", () => {
    alert(button.id);
  });
});
```
## 3. Event Flow
```html
`<!DOCTYPE html> 
<html> 
<head>     
	<title>JS Event Demo</title> 
</head> 

<body>     
	<div id="container">         
		<button id='btn'>Click Me!</button>     
	</div> 
</body>
```
When you click the button, you’re clicking not only the button but also the button’s container, the `div`, and the whole webpage. 

→ Even flow explains the order in which events are received on the page from the element where the event occurs and propagated through the DOM tree. 

**There are two main event models: event bubbling and event capturing.** 
### 1. Event Bubbling
In the **event bubbling model**, an event starts at the **most specific element** and then flows **upward** toward the **least specific element** (the `document` or even `window`).

For example, when you click the button, the `click` event occurs with the following order
1. `<button>`
2. `<div>` with `id="container"`
3. `<body>`
4. `<html>`
5. `document`

The `click` event goes up the DOM tree, firing on each node along its way until it reaches the `document` object. Modern web browsers bubble the even up to the `window` object. 
![](https://i.imgur.com/3BhWRYs.png)
### 2. Event Capturing
In the **event capturing model**, an event starts at the **least specific element** and **flows downward** toward the **most specific element**. 